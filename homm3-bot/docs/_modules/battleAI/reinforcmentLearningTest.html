<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>battleAI.reinforcmentLearningTest &mdash; HoMM3 Bot 2.0 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> HoMM3 Bot
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">homm3-bot</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">HoMM3 Bot</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">battleAI.reinforcmentLearningTest</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for battleAI.reinforcmentLearningTest</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">random</span> <span class="k">as</span> <span class="nn">rd</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">data.BattleAI_environment_needs</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">battleAI.damage</span> <span class="kn">import</span> <span class="n">baseDamage</span>
<span class="kn">from</span> <span class="nn">battleAI.queue_test</span> <span class="kn">import</span> <span class="n">BattleQueue</span>


<div class="viewcode-block" id="divideIntoAllyAndEnemy"><a class="viewcode-back" href="../../battleAI.html#battleAI.reinforcmentLearningTest.divideIntoAllyAndEnemy">[docs]</a><span class="k">def</span> <span class="nf">divideIntoAllyAndEnemy</span><span class="p">(</span><span class="n">setOfCreatures</span><span class="p">:</span> <span class="nb">list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function which divides list with all creatures into lists with allied creatures and hostile creatures</span>

<span class="sd">    :param setOfCreatures: list with all the creatures</span>
<span class="sd">    :return ally: list with allied creatures</span>
<span class="sd">    :return enemy: list with hostile creatures</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ally</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">enemy</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">mob</span> <span class="ow">in</span> <span class="n">setOfCreatures</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">mob</span><span class="o">.</span><span class="n">ally</span><span class="p">:</span>
            <span class="n">ally</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mob</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">enemy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mob</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ally</span><span class="p">,</span> <span class="n">enemy</span></div>


<div class="viewcode-block" id="even"><a class="viewcode-back" href="../../battleAI.html#battleAI.reinforcmentLearningTest.even">[docs]</a><span class="k">def</span> <span class="nf">even</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns True if value is even, False otherwise</span>

<span class="sd">    :rtype: int value</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="odd"><a class="viewcode-back" href="../../battleAI.html#battleAI.reinforcmentLearningTest.odd">[docs]</a><span class="k">def</span> <span class="nf">odd</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns True if value is odd, False otherwise</span>

<span class="sd">    :rtype: int value</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="getNeighbours"><a class="viewcode-back" href="../../battleAI.html#battleAI.reinforcmentLearningTest.getNeighbours">[docs]</a><span class="k">def</span> <span class="nf">getNeighbours</span><span class="p">(</span><span class="n">hexField</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function which gets all the neighbours of specific tile at the hexagonal field</span>

<span class="sd">    :param hexField: input position</span>
<span class="sd">    :return neighbours: dictionary where key is tuple position and value is string which describes direction like</span>
<span class="sd">        &quot;right&quot;, &quot;left&quot;, &quot;bottom_right&quot; etc. It is needed for detecting direction when attacking.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">hexField</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">hexField</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Selecting neighbours</span>
    <span class="n">neighbours</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">odd</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span> <span class="n">neighbours</span><span class="p">[</span><span class="s2">&quot;bottom_right&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">neighbours</span><span class="p">[</span><span class="s2">&quot;top_right&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">14</span><span class="p">:</span> <span class="n">neighbours</span><span class="p">[</span><span class="s2">&quot;right&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">neighbours</span><span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">neighbours</span><span class="p">[</span><span class="s2">&quot;top_left&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span> <span class="n">neighbours</span><span class="p">[</span><span class="s2">&quot;bottom_left&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span> <span class="n">neighbours</span><span class="p">[</span><span class="s2">&quot;bottom_left&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">neighbours</span><span class="p">[</span><span class="s2">&quot;top_left&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">neighbours</span><span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">14</span><span class="p">:</span>
            <span class="n">neighbours</span><span class="p">[</span><span class="s2">&quot;right&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span> <span class="n">neighbours</span><span class="p">[</span><span class="s2">&quot;bottom_right&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">neighbours</span><span class="p">[</span><span class="s2">&quot;top_right&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">neighbours</span></div>


<span class="c1"># class for coloring text printed in console</span>
<div class="viewcode-block" id="Colors"><a class="viewcode-back" href="../../battleAI.html#battleAI.reinforcmentLearningTest.Colors">[docs]</a><span class="k">class</span> <span class="nc">Colors</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Dataclass with defined colors of the text written in console. To use it just write</span>
<span class="sd">    print(Colors.&lt;name_of_color&gt; + text + Colors.ENDC). Colors.ENDC is necessary if we want back to the original color</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">HEADER</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\033</span><span class="s1">[95m&#39;</span>
    <span class="n">OKBLUE</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\033</span><span class="s1">[94m&#39;</span>
    <span class="n">OKCYAN</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\033</span><span class="s1">[96m&#39;</span>
    <span class="n">OKGREEN</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\033</span><span class="s1">[92m&#39;</span>
    <span class="n">WARNING</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\033</span><span class="s1">[93m&#39;</span>
    <span class="n">FAIL</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\033</span><span class="s1">[91m&#39;</span>
    <span class="n">ENDC</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\033</span><span class="s1">[0m&#39;</span>
    <span class="n">BOLD</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\033</span><span class="s1">[1m&#39;</span>
    <span class="n">UNDERLINE</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\033</span><span class="s1">[4m&#39;</span></div>


<div class="viewcode-block" id="Environment"><a class="viewcode-back" href="../../battleAI.html#battleAI.reinforcmentLearningTest.Environment">[docs]</a><span class="k">class</span> <span class="nc">Environment</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">setOfCreatures</span><span class="p">,</span> <span class="n">setOfObstacles</span><span class="p">,</span> <span class="n">training</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This class implements battle environment used in learning BattleAI and making predictions in game by it.</span>

<span class="sd">        :param setOfCreatures: list with all the creatures at the battlefield</span>
<span class="sd">        :param setOfObstacles: list with all the obstacles at the battlefield</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">possibleMoves</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">15</span><span class="p">,</span> <span class="mi">11</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">illegalMove</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">training</span> <span class="o">=</span> <span class="n">training</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">resetEnv</span><span class="p">(</span><span class="n">setOfCreatures</span><span class="p">,</span> <span class="n">setOfObstacles</span><span class="p">)</span>

        <span class="c1"># Temporary solution till queue will be upgraded</span>
        <span class="n">ally</span><span class="p">,</span> <span class="n">enemy</span> <span class="o">=</span> <span class="n">divideIntoAllyAndEnemy</span><span class="p">(</span><span class="n">setOfCreatures</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">queue</span> <span class="o">=</span> <span class="n">BattleQueue</span><span class="p">(</span><span class="n">ally</span><span class="p">,</span> <span class="n">enemy</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">obstacles</span> <span class="o">=</span> <span class="n">setOfObstacles</span>

        <span class="c1"># Dealing damage contains a random element meaning our environment can sometimes decide</span>
        <span class="c1"># that our unit died from counterattack even if it didn&#39;t and delete it from the battlefield</span>
        <span class="c1"># set it to False to prevent that from happening</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allowDying</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">siege_walls</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">moat</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># {coordinates:hp}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">destructible_walls</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="Environment.resetEnv"><a class="viewcode-back" href="../../battleAI.html#battleAI.reinforcmentLearningTest.Environment.resetEnv">[docs]</a>    <span class="k">def</span> <span class="nf">resetEnv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">setOfCreatures</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">setOfObstacles</span><span class="p">:</span> <span class="nb">list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function which resets the environment.</span>

<span class="sd">        :param setOfCreatures: list with all the creatures at the battlefield</span>
<span class="sd">        :param setOfObstacles: list with all the obstacles at the battlefield</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">15</span><span class="p">,</span> <span class="mi">11</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__initializeCreatures</span><span class="p">(</span><span class="n">setOfCreatures</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__initializeObstacles</span><span class="p">(</span><span class="n">setOfObstacles</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__initializeCreatures</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">setOfCreatures</span><span class="p">:</span> <span class="nb">list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function which adds creatures to the game state (battlefield array)</span>

<span class="sd">        :param setOfCreatures: list with all the creatures at the battlefield</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Part of state definition, putting creatures to the environment</span>
        <span class="k">for</span> <span class="n">mob</span> <span class="ow">in</span> <span class="n">setOfCreatures</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">mob</span><span class="o">.</span><span class="n">field</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">mob</span>

            <span class="c1"># If unit is 2hex size, we need to add additional &quot;tail&quot; of the creature</span>
            <span class="k">if</span> <span class="n">mob</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">mob</span><span class="o">.</span><span class="n">ally</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">mob</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">y</span><span class="p">]</span><span class="o">.</span><span class="n">field</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">mob</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">y</span><span class="p">]</span><span class="o">.</span><span class="n">field</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__initializeObstacles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">setOfObstacles</span><span class="p">:</span> <span class="nb">list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function which adds obstacles to the game state (battlefield array).</span>

<span class="sd">        :param setOfObstacles: list with all the obstacles at the battlefield</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Part of state definition, putting obstacles to the environment (hexes we cannot move on)</span>
        <span class="k">for</span> <span class="n">obstacle</span> <span class="ow">in</span> <span class="n">setOfObstacles</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">obstacle</span><span class="o">.</span><span class="n">field</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">obstacle</span>

    <span class="k">def</span> <span class="nf">__swapCreatureWithEmptySlot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function which moves creature or creature part (for two hex units) with the empty space at the battlefield.</span>

<span class="sd">        :param start: creature or creature part position</span>
<span class="sd">        :param target: empty spaces we want to swap with creature</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="n">start</span>
        <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">target</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x2</span><span class="p">][</span><span class="n">y2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x1</span><span class="p">][</span><span class="n">y1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x2</span><span class="p">][</span><span class="n">y2</span><span class="p">]</span><span class="o">.</span><span class="n">field</span> <span class="o">=</span> <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x1</span><span class="p">][</span><span class="n">y1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">__del2HexFromState</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function which deletes 2hex unit from game state</span>

<span class="sd">        :param target: (tuple) tail or head position of the unit we want delete</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">target</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">elif</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">14</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span><span class="o">.</span><span class="n">eqLeft</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span><span class="o">.</span><span class="n">eqRight</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">__unit2HexStatsActualization</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">newHP</span><span class="p">,</span> <span class="n">newQuantity</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function which actualize health points and quantity of the unit. Used after counterattack.</span>

<span class="sd">        :param target: (tuple) Position of the unit in battlefield we want to actualize</span>
<span class="sd">        :param newHP: (int) New health points for changing stackHP attribute</span>
<span class="sd">        :param newQuantity: (int) New quantity number for changing quantity attribute</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">target</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span><span class="o">.</span><span class="n">stackHP</span> <span class="o">=</span> <span class="n">newHP</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span><span class="o">.</span><span class="n">quantity</span> <span class="o">=</span> <span class="n">newQuantity</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span><span class="o">.</span><span class="n">stackHP</span> <span class="o">=</span> <span class="n">newHP</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span><span class="o">.</span><span class="n">quantity</span> <span class="o">=</span> <span class="n">newQuantity</span>

        <span class="k">elif</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">14</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span><span class="o">.</span><span class="n">stackHP</span> <span class="o">=</span> <span class="n">newHP</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span><span class="o">.</span><span class="n">quantity</span> <span class="o">=</span> <span class="n">newQuantity</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span><span class="o">.</span><span class="n">stackHP</span> <span class="o">=</span> <span class="n">newHP</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span><span class="o">.</span><span class="n">quantity</span> <span class="o">=</span> <span class="n">newQuantity</span>

        <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span><span class="o">.</span><span class="n">eqLeft</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span><span class="o">.</span><span class="n">eqRight</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span><span class="o">.</span><span class="n">stackHP</span> <span class="o">=</span> <span class="n">newHP</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span><span class="o">.</span><span class="n">quantity</span> <span class="o">=</span> <span class="n">newQuantity</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span><span class="o">.</span><span class="n">stackHP</span> <span class="o">=</span> <span class="n">newHP</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span><span class="o">.</span><span class="n">quantity</span> <span class="o">=</span> <span class="n">newQuantity</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span><span class="o">.</span><span class="n">stackHP</span> <span class="o">=</span> <span class="n">newHP</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span><span class="o">.</span><span class="n">quantity</span> <span class="o">=</span> <span class="n">newQuantity</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span><span class="o">.</span><span class="n">stackHP</span> <span class="o">=</span> <span class="n">newHP</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span><span class="o">.</span><span class="n">quantity</span> <span class="o">=</span> <span class="n">newQuantity</span>

    <span class="k">def</span> <span class="nf">__rangeAttack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function which simulates ranged attack. It takes as parameter only target of attack. Executor of the attack</span>
<span class="sd">        is the first</span>

<span class="sd">        :param target: (tuple) position of the target creature we want attack</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># 1. Declaring attacker and defender</span>
        <span class="n">attacker</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">queue</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">defender</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">target</span><span class="p">]</span>

        <span class="c1"># 2. Attacker attacks defender</span>
        <span class="n">damageAttack</span> <span class="o">=</span> <span class="n">baseDamage</span><span class="p">(</span><span class="n">attacker</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">damage</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">attacker</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">damage</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">attacker</span><span class="o">.</span><span class="n">quantity</span><span class="p">)</span>
        <span class="n">DefenderNewHP</span> <span class="o">=</span> <span class="n">defender</span><span class="o">.</span><span class="n">stackHP</span> <span class="o">-</span> <span class="n">damageAttack</span>
        <span class="n">DefenderNewQuantity</span> <span class="o">=</span> <span class="n">DefenderNewHP</span> <span class="o">//</span> <span class="n">defender</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">hp</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># Decrease the amount of ammo</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">queue</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">ammo</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="c1"># 3. If hps less than zero, delete defender from environment</span>
        <span class="k">if</span> <span class="n">DefenderNewHP</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">allowDying</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">mob</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">queue</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">mob</span> <span class="o">==</span> <span class="n">defender</span><span class="p">:</span>
                    <span class="c1"># Delete unit from state</span>
                    <span class="k">if</span> <span class="n">defender</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">__del2HexFromState</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

                    <span class="c1"># Delete from queue</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">queue</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">break</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">DefenderNewHP</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">DefenderNewHP</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># Defender statistics actualization</span>
            <span class="k">if</span> <span class="n">defender</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># Tail actualization</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__unit2HexStatsActualization</span><span class="p">(</span><span class="n">defender</span><span class="o">.</span><span class="n">field</span><span class="p">,</span> <span class="n">DefenderNewHP</span><span class="p">,</span> <span class="n">DefenderNewQuantity</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">target</span><span class="p">]</span><span class="o">.</span><span class="n">stackHP</span> <span class="o">=</span> <span class="n">DefenderNewHP</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">target</span><span class="p">]</span><span class="o">.</span><span class="n">quantity</span> <span class="o">=</span> <span class="n">DefenderNewQuantity</span>

    <span class="k">def</span> <span class="nf">__meleeAttack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulates a melee attack</span>

<span class="sd">        :param target: (tuple) indices of the targeted tile</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># 1. Declaring attacker and defender</span>
        <span class="n">attacker</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">queue</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">defender</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">target</span><span class="p">]</span>

        <span class="c1"># 2. Attacker attacks defender</span>
        <span class="n">damageAttack</span> <span class="o">=</span> <span class="n">baseDamage</span><span class="p">(</span><span class="n">attacker</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">damage</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">attacker</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">damage</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">attacker</span><span class="o">.</span><span class="n">quantity</span><span class="p">)</span>
        <span class="n">DefenderNewHP</span> <span class="o">=</span> <span class="n">defender</span><span class="o">.</span><span class="n">stackHP</span> <span class="o">-</span> <span class="n">damageAttack</span>
        <span class="n">DefenderNewQuantity</span> <span class="o">=</span> <span class="n">DefenderNewHP</span> <span class="o">//</span> <span class="n">defender</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">hp</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># 3. If hps less than zero, delete defender from environment</span>
        <span class="k">if</span> <span class="n">DefenderNewHP</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">allowDying</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">mob</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">queue</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">mob</span> <span class="o">==</span> <span class="n">defender</span><span class="p">:</span>
                    <span class="c1"># Delete unit from state</span>
                    <span class="k">if</span> <span class="n">defender</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">__del2HexFromState</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

                    <span class="c1"># Delete from queue</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">queue</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">DefenderNewHP</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">DefenderNewHP</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># 4. If defender is still alive, he counterattacks</span>
            <span class="n">damageCounterAttack</span> <span class="o">=</span> <span class="n">baseDamage</span><span class="p">(</span><span class="n">defender</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">damage</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">defender</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">damage</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">DefenderNewQuantity</span><span class="p">)</span>
            <span class="n">AttackerNewHP</span> <span class="o">=</span> <span class="n">attacker</span><span class="o">.</span><span class="n">stackHP</span> <span class="o">-</span> <span class="n">damageCounterAttack</span>
            <span class="n">AttackerNewQuantity</span> <span class="o">=</span> <span class="n">AttackerNewHP</span> <span class="o">//</span> <span class="n">attacker</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">hp</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="c1"># 5. If hps less than zero, delete attacker from environment</span>
            <span class="k">if</span> <span class="n">AttackerNewHP</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">allowDying</span><span class="p">:</span>
                <span class="c1"># Delete unit from state</span>
                <span class="k">if</span> <span class="n">attacker</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__del2HexFromState</span><span class="p">(</span><span class="n">attacker</span><span class="o">.</span><span class="n">field</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">attacker</span><span class="o">.</span><span class="n">field</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="c1"># Delete from queue</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">queue</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">else</span><span class="p">:</span>  <span class="c1"># Attacker statistics actualization</span>
                <span class="k">if</span> <span class="n">AttackerNewHP</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">AttackerNewHP</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="n">attacker</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># 2Hex actualization</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__unit2HexStatsActualization</span><span class="p">(</span><span class="n">attacker</span><span class="o">.</span><span class="n">field</span><span class="p">,</span> <span class="n">AttackerNewHP</span><span class="p">,</span> <span class="n">AttackerNewQuantity</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">attacker</span><span class="o">.</span><span class="n">field</span><span class="p">]</span><span class="o">.</span><span class="n">stackHP</span> <span class="o">=</span> <span class="n">AttackerNewHP</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">attacker</span><span class="o">.</span><span class="n">field</span><span class="p">]</span><span class="o">.</span><span class="n">quantity</span> <span class="o">=</span> <span class="n">AttackerNewQuantity</span>

            <span class="c1"># Defender statistics actualization</span>
            <span class="k">if</span> <span class="n">defender</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># Tail actualization</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__unit2HexStatsActualization</span><span class="p">(</span><span class="n">defender</span><span class="o">.</span><span class="n">field</span><span class="p">,</span> <span class="n">DefenderNewHP</span><span class="p">,</span> <span class="n">DefenderNewQuantity</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">target</span><span class="p">]</span><span class="o">.</span><span class="n">stackHP</span> <span class="o">=</span> <span class="n">DefenderNewHP</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">target</span><span class="p">]</span><span class="o">.</span><span class="n">quantity</span> <span class="o">=</span> <span class="n">DefenderNewQuantity</span>

    <span class="k">def</span> <span class="nf">__movingAndAttacking</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">startPos</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs action of moving and attacking 1-hex unit</span>

<span class="sd">        :param startPos: (tuple) starting indices of the attacker</span>
<span class="sd">        :param target:  (tuple) indices of the attack target</span>
<span class="sd">        :return: (str) side of the attack target we attack it from</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">neighbours</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__getEmptyNeighbours</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">neighbours</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No neighbours, cant attack&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">illegalMove</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">key</span><span class="p">,</span> <span class="n">endPos</span> <span class="o">=</span> <span class="n">rd</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">neighbours</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>
        <span class="n">return_after</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">mob</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="s2">&quot;Strike and return&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">queue</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">abilities</span><span class="p">:</span>
            <span class="n">return_after</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">mob</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">queue</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__moving</span><span class="p">(</span><span class="n">startPos</span><span class="p">,</span> <span class="n">endPos</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__meleeAttack</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_after</span> <span class="ow">and</span> <span class="n">mob</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">queue</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">undoMove</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__moving</span><span class="p">(</span><span class="n">endPos</span><span class="p">,</span> <span class="n">startPos</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">key</span>

    <span class="k">def</span> <span class="nf">__movingAndAttacking2Hex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">startPos</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs action of moving and attacking 2-hex unit</span>

<span class="sd">        :param startPos: (tuple) starting indices of the attacker</span>
<span class="sd">        :param target:  (tuple) indices of the attack target</span>
<span class="sd">        :return: (str) side of the attack target we attack it from</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># 1 Get neighbours and choose one randomly</span>
        <span class="n">neighbours</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__getEmptyNeighbours2Hex</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">neighbours</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No neighbours, cant attack&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">illegalMove</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">key</span><span class="p">,</span> <span class="n">way</span> <span class="o">=</span> <span class="n">rd</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">neighbours</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>

        <span class="c1"># 2. Make some corrections</span>
        <span class="n">mob</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">queue</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">mob</span><span class="o">.</span><span class="n">ally</span> <span class="ow">and</span> <span class="p">(</span><span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;bottom_right&quot;</span> <span class="ow">or</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;top_right&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__moving2Hex</span><span class="p">(</span><span class="n">startPos</span><span class="p">,</span> <span class="p">(</span><span class="n">way</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">way</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">mob</span><span class="o">.</span><span class="n">ally</span> <span class="ow">and</span> <span class="p">(</span><span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;bottom_left&quot;</span> <span class="ow">or</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;top_left&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__moving2Hex</span><span class="p">(</span><span class="n">startPos</span><span class="p">,</span> <span class="p">(</span><span class="n">way</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">way</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__moving2Hex</span><span class="p">(</span><span class="n">startPos</span><span class="p">,</span> <span class="n">way</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__meleeAttack</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">key</span>

    <span class="k">def</span> <span class="nf">__moving</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">):</span>  <span class="c1"># Moving action</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs moving action of a 1-hex unit</span>

<span class="sd">        :param start: (tuple) starting indices of a unit</span>
<span class="sd">        :param target: (tuple) target indices</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Case when we are in neighbourhood of the opponent and dont want to change our position but only attack him</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">move</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__swapCreatureWithEmptySlot</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">queue</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">field</span> <span class="o">=</span> <span class="n">target</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">move</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__moving2Hex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">):</span>  <span class="c1"># Moving action</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs moving action of a 2-hex unit</span>

<span class="sd">        :param head: (tuple) starting indices of a unit&#39;s head</span>
<span class="sd">        :param target: (tuple) target indices</span>
<span class="sd">        :return: None - if the unit didn&#39;t move</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="n">head</span>
        <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">target</span>
        <span class="c1"># Case when we are in neighbourhood of the opponent and dont want to change our position but only attack him</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Move queue</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">move</span><span class="p">()</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Initializing some variables for code reduction</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">queue</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">ally</span><span class="p">:</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># if mob is ally we need to check left side firstly</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># for ally start of board is 0, this is needed for boundary cases execution</span>
            <span class="n">end</span> <span class="o">=</span> <span class="mi">14</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">14</span>
            <span class="n">end</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Moving &quot;tail&quot; and &quot;head&quot; of the creature</span>
        <span class="k">if</span> <span class="n">x2</span> <span class="o">==</span> <span class="n">start</span><span class="p">:</span>  <span class="c1"># Start of the map exception</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x2</span> <span class="o">+</span> <span class="n">tail</span><span class="p">,</span> <span class="n">y2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__swapCreatureWithEmptySlot</span><span class="p">((</span><span class="n">x1</span> <span class="o">-</span> <span class="n">tail</span><span class="p">,</span> <span class="n">y1</span><span class="p">),</span> <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">))</span>  <span class="c1"># Moving tail</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__swapCreatureWithEmptySlot</span><span class="p">((</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">),</span> <span class="p">(</span><span class="n">x2</span> <span class="o">+</span> <span class="n">tail</span><span class="p">,</span> <span class="n">y2</span><span class="p">))</span>  <span class="c1"># Moving head</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># print(&quot;I cant move on this hex&quot;)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">illegalMove</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">return</span> <span class="kc">None</span>

        <span class="k">elif</span> <span class="n">x2</span> <span class="o">==</span> <span class="n">end</span><span class="p">:</span>  <span class="c1"># End of the map exception when only 1hex space</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x2</span> <span class="o">-</span> <span class="n">tail</span><span class="p">,</span> <span class="n">y2</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># print(&quot;I cant move on this hex&quot;)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">illegalMove</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">return</span> <span class="kc">None</span>

        <span class="k">elif</span> <span class="n">x1</span> <span class="o">==</span> <span class="n">x2</span> <span class="o">-</span> <span class="n">tail</span> <span class="ow">and</span> <span class="n">y1</span> <span class="o">==</span> <span class="n">y2</span><span class="p">:</span>  <span class="c1"># Move one hex to the front exception</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__swapCreatureWithEmptySlot</span><span class="p">((</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">),</span> <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">))</span>  <span class="c1"># Moving head</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__swapCreatureWithEmptySlot</span><span class="p">((</span><span class="n">x1</span> <span class="o">-</span> <span class="n">tail</span><span class="p">,</span> <span class="n">y1</span><span class="p">),</span> <span class="p">(</span><span class="n">x2</span> <span class="o">-</span> <span class="n">tail</span><span class="p">,</span> <span class="n">y2</span><span class="p">))</span>  <span class="c1"># Moving tail</span>

        <span class="k">elif</span> <span class="n">x1</span> <span class="o">==</span> <span class="n">x2</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">tail</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span>
            <span class="n">x1</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">tail</span><span class="p">,</span> <span class="n">y1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">y1</span> <span class="o">==</span> <span class="n">y2</span><span class="p">:</span>  <span class="c1"># Move one hex to the back exception</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__swapCreatureWithEmptySlot</span><span class="p">((</span><span class="n">x1</span> <span class="o">-</span> <span class="n">tail</span><span class="p">,</span> <span class="n">y1</span><span class="p">),</span> <span class="p">(</span><span class="n">x1</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">tail</span><span class="p">,</span> <span class="n">y2</span><span class="p">))</span>  <span class="c1"># Moving tail</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__swapCreatureWithEmptySlot</span><span class="p">((</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">),</span> <span class="p">(</span><span class="n">x1</span> <span class="o">-</span> <span class="n">tail</span><span class="p">,</span> <span class="n">y2</span><span class="p">))</span>  <span class="c1"># Moving head</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x2</span> <span class="o">-</span> <span class="n">tail</span><span class="p">,</span> <span class="n">y2</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span>
            <span class="n">x2</span> <span class="o">+</span> <span class="n">tail</span><span class="p">,</span> <span class="n">y2</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># 1hex space in the interior of map exception</span>
            <span class="c1"># print(&quot;I cant move on this hex&quot;)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">illegalMove</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x2</span> <span class="o">-</span> <span class="n">tail</span><span class="p">][</span><span class="n">y2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">possibleMoves</span><span class="p">[</span><span class="n">x2</span> <span class="o">-</span> <span class="n">tail</span><span class="p">,</span> <span class="n">y2</span><span class="p">]:</span>
            <span class="c1"># After moving, tail still on the back side</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__swapCreatureWithEmptySlot</span><span class="p">((</span><span class="n">x1</span> <span class="o">-</span> <span class="n">tail</span><span class="p">,</span> <span class="n">y1</span><span class="p">),</span> <span class="p">(</span><span class="n">x2</span> <span class="o">-</span> <span class="n">tail</span><span class="p">,</span> <span class="n">y2</span><span class="p">))</span>  <span class="c1"># Moving tail</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__swapCreatureWithEmptySlot</span><span class="p">((</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">),</span> <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">))</span>  <span class="c1"># Moving head</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># After moving, tail on the right side so we need to inverse head and tail</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__swapCreatureWithEmptySlot</span><span class="p">((</span><span class="n">x1</span> <span class="o">-</span> <span class="n">tail</span><span class="p">,</span> <span class="n">y1</span><span class="p">),</span> <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">))</span>  <span class="c1"># Moving tail</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__swapCreatureWithEmptySlot</span><span class="p">((</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">),</span> <span class="p">(</span><span class="n">x2</span> <span class="o">+</span> <span class="n">tail</span><span class="p">,</span> <span class="n">y2</span><span class="p">))</span>  <span class="c1"># Moving head</span>

        <span class="c1"># Move queue</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">move</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__getEmptyNeighbours2Hex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hexField</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds empty neighbouring tiles of 2-hex unit</span>

<span class="sd">        :param hexField: (tuple) indices of the 2-hex unit</span>
<span class="sd">        :return: (list) of indices of empty neighbouring tiles</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">getNeighbours</span><span class="p">(</span><span class="n">hexField</span><span class="p">)</span>
        <span class="n">neighbours</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># 0. Remembering first mob from the queue position and its tail</span>
        <span class="n">mob</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">queue</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">mobx</span><span class="p">,</span> <span class="n">moby</span> <span class="o">=</span> <span class="n">mob</span><span class="o">.</span><span class="n">field</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">mobx</span><span class="p">,</span> <span class="n">moby</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">mob</span><span class="o">.</span><span class="n">ally</span><span class="p">:</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">mobx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">moby</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">mobx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">moby</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">mobx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">moby</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">mobx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">moby</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">value</span>
            <span class="c1"># 1. The most important condition is empty neighbour</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">possibleMoves</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]:</span>
                <span class="c1"># 2. Then we need to check 6 main cases with 2-3 sub-cases</span>
                <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;bottom_right&quot;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Start of the map exception</span>
                        <span class="c1"># For this exception we need to check right place only</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">possibleMoves</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">]:</span>
                            <span class="k">continue</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">del</span> <span class="n">neighbours</span><span class="p">[</span><span class="s1">&#39;bottom_right&#39;</span><span class="p">]</span>
                            <span class="k">continue</span>

                    <span class="k">elif</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">14</span><span class="p">:</span>  <span class="c1"># End of the map exception</span>
                        <span class="c1"># For this exception we need to check left place only</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">possibleMoves</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">]:</span>
                            <span class="n">neighbours</span><span class="p">[</span><span class="s1">&#39;bottom&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">neighbours</span><span class="p">[</span><span class="s1">&#39;bottom_right&#39;</span><span class="p">]</span>
                            <span class="k">del</span> <span class="n">neighbours</span><span class="p">[</span><span class="s1">&#39;bottom_right&#39;</span><span class="p">]</span>
                            <span class="k">continue</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">del</span> <span class="n">neighbours</span><span class="p">[</span><span class="s1">&#39;bottom_right&#39;</span><span class="p">]</span>
                            <span class="k">continue</span>

                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># For bottom right neighbour we need to check right place first</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">possibleMoves</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">]:</span>
                            <span class="k">continue</span>
                        <span class="c1"># If right neighbour is not empty check left neighbour</span>
                        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">possibleMoves</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">]:</span>
                            <span class="c1"># If empty we need to change bottom right for bottom because of the specifics of 2hex units</span>
                            <span class="n">neighbours</span><span class="p">[</span><span class="s1">&#39;bottom&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">neighbours</span><span class="p">[</span><span class="s1">&#39;bottom_right&#39;</span><span class="p">]</span>
                            <span class="k">del</span> <span class="n">neighbours</span><span class="p">[</span><span class="s1">&#39;bottom_right&#39;</span><span class="p">]</span>
                            <span class="k">continue</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">del</span> <span class="n">neighbours</span><span class="p">[</span><span class="s1">&#39;bottom_right&#39;</span><span class="p">]</span>
                            <span class="k">continue</span>

                <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;bottom_left&quot;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Start of the map exception</span>
                        <span class="c1"># For this exception we need to check right place only</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">possibleMoves</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">]:</span>
                            <span class="n">neighbours</span><span class="p">[</span><span class="s1">&#39;bottom&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">neighbours</span><span class="p">[</span><span class="s1">&#39;bottom_left&#39;</span><span class="p">]</span>
                            <span class="k">del</span> <span class="n">neighbours</span><span class="p">[</span><span class="s1">&#39;bottom_left&#39;</span><span class="p">]</span>
                            <span class="k">continue</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">del</span> <span class="n">neighbours</span><span class="p">[</span><span class="s1">&#39;bottom_left&#39;</span><span class="p">]</span>
                            <span class="k">continue</span>

                    <span class="k">elif</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">14</span><span class="p">:</span>  <span class="c1"># End of the map exception</span>
                        <span class="c1"># For this exception we need to check left place only</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">possibleMoves</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">]:</span>
                            <span class="k">del</span> <span class="n">neighbours</span><span class="p">[</span><span class="s1">&#39;bottom_left&#39;</span><span class="p">]</span>
                            <span class="k">continue</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">neighbours</span><span class="p">[</span><span class="s1">&#39;bottom_left&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">neighbours</span><span class="p">[</span><span class="s1">&#39;bottom_left&#39;</span><span class="p">]</span>
                            <span class="k">del</span> <span class="n">neighbours</span><span class="p">[</span><span class="s1">&#39;bottom_left&#39;</span><span class="p">]</span>
                            <span class="k">continue</span>

                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># For bottom left neighbour we need to check left place first</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">possibleMoves</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">]:</span>
                            <span class="k">continue</span>
                        <span class="c1"># If left neighbour is not empty check right neighbour</span>
                        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">possibleMoves</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">]:</span>
                            <span class="c1"># If empty we need to change bottom left for bottom because of the specifics of 2hex units</span>
                            <span class="n">neighbours</span><span class="p">[</span><span class="s1">&#39;bottom&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">neighbours</span><span class="p">[</span><span class="s1">&#39;bottom_left&#39;</span><span class="p">]</span>
                            <span class="k">del</span> <span class="n">neighbours</span><span class="p">[</span><span class="s1">&#39;bottom_left&#39;</span><span class="p">]</span>
                            <span class="k">continue</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">del</span> <span class="n">neighbours</span><span class="p">[</span><span class="s1">&#39;bottom_left&#39;</span><span class="p">]</span>
                            <span class="k">continue</span>

                <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;top_right&quot;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Start of the map exception</span>
                        <span class="c1"># For this exception we need to check right place only</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">possibleMoves</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">]:</span>
                            <span class="k">continue</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">del</span> <span class="n">neighbours</span><span class="p">[</span><span class="s1">&#39;top_right&#39;</span><span class="p">]</span>
                            <span class="k">continue</span>

                    <span class="k">elif</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">14</span><span class="p">:</span>  <span class="c1"># End of the map exception</span>
                        <span class="c1"># For this exception we need to check left place only</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">possibleMoves</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">]:</span>
                            <span class="n">neighbours</span><span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">neighbours</span><span class="p">[</span><span class="s1">&#39;top_right&#39;</span><span class="p">]</span>
                            <span class="k">del</span> <span class="n">neighbours</span><span class="p">[</span><span class="s1">&#39;top_right&#39;</span><span class="p">]</span>
                            <span class="k">continue</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">del</span> <span class="n">neighbours</span><span class="p">[</span><span class="s1">&#39;top_right&#39;</span><span class="p">]</span>
                            <span class="k">continue</span>

                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># SIMILAR TO BOTTOM RIGHT</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">possibleMoves</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">]:</span>
                            <span class="k">continue</span>
                        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">possibleMoves</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">]:</span>
                            <span class="n">neighbours</span><span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">neighbours</span><span class="p">[</span><span class="s1">&#39;top_right&#39;</span><span class="p">]</span>
                            <span class="k">del</span> <span class="n">neighbours</span><span class="p">[</span><span class="s1">&#39;top_right&#39;</span><span class="p">]</span>
                            <span class="k">continue</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">del</span> <span class="n">neighbours</span><span class="p">[</span><span class="s1">&#39;top_right&#39;</span><span class="p">]</span>
                            <span class="k">continue</span>

                <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;top_left&quot;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Start of the map exception</span>
                        <span class="c1"># For this exception we need to check right place only</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">possibleMoves</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">]:</span>
                            <span class="n">neighbours</span><span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">neighbours</span><span class="p">[</span><span class="s1">&#39;top_left&#39;</span><span class="p">]</span>
                            <span class="k">del</span> <span class="n">neighbours</span><span class="p">[</span><span class="s1">&#39;top_left&#39;</span><span class="p">]</span>
                            <span class="k">continue</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">del</span> <span class="n">neighbours</span><span class="p">[</span><span class="s1">&#39;top_left&#39;</span><span class="p">]</span>
                            <span class="k">continue</span>

                    <span class="k">elif</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">14</span><span class="p">:</span>  <span class="c1"># End of the map exception</span>
                        <span class="c1"># For this exception we need to check left place only</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">possibleMoves</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">]:</span>
                            <span class="k">del</span> <span class="n">neighbours</span><span class="p">[</span><span class="s1">&#39;top_left&#39;</span><span class="p">]</span>
                            <span class="k">continue</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">neighbours</span><span class="p">[</span><span class="s1">&#39;top_left&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">neighbours</span><span class="p">[</span><span class="s1">&#39;top_left&#39;</span><span class="p">]</span>
                            <span class="k">del</span> <span class="n">neighbours</span><span class="p">[</span><span class="s1">&#39;top_left&#39;</span><span class="p">]</span>
                            <span class="k">continue</span>

                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># SIMILAR TO BOTTOM_LEFT</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">possibleMoves</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">]:</span>
                            <span class="k">continue</span>
                        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">possibleMoves</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">]:</span>
                            <span class="n">neighbours</span><span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">neighbours</span><span class="p">[</span><span class="s1">&#39;top_left&#39;</span><span class="p">]</span>
                            <span class="k">del</span> <span class="n">neighbours</span><span class="p">[</span><span class="s1">&#39;top_left&#39;</span><span class="p">]</span>
                            <span class="k">continue</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">del</span> <span class="n">neighbours</span><span class="p">[</span><span class="s1">&#39;top_left&#39;</span><span class="p">]</span>
                            <span class="k">continue</span>

                <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;right&quot;</span><span class="p">:</span>
                    <span class="c1"># Need to check only neighbour in the right side</span>
                    <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">14</span><span class="p">:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">possibleMoves</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">]:</span>
                            <span class="k">continue</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">del</span> <span class="n">neighbours</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span>
                            <span class="k">continue</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">del</span> <span class="n">neighbours</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span>
                        <span class="k">continue</span>

                <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;left&quot;</span><span class="p">:</span>
                    <span class="c1"># Need to check only neighbour in the left side</span>
                    <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">possibleMoves</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">]:</span>
                            <span class="k">continue</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">del</span> <span class="n">neighbours</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">]</span>
                            <span class="k">continue</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">del</span> <span class="n">neighbours</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">]</span>
                        <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">neighbours</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">mobx</span><span class="p">,</span> <span class="n">moby</span><span class="p">]</span> <span class="o">=</span> <span class="n">mob</span>
        <span class="k">if</span> <span class="n">mob</span><span class="o">.</span><span class="n">ally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">mobx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">moby</span><span class="p">]</span> <span class="o">=</span> <span class="n">tail</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">mobx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">moby</span><span class="p">]</span> <span class="o">=</span> <span class="n">tail</span>

        <span class="k">return</span> <span class="n">neighbours</span>

    <span class="k">def</span> <span class="nf">__getEmptyNeighbours</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hexField</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds empty neighbouring tiles of 1-hex unit</span>

<span class="sd">        :param hexField: (tuple) indices of the 1-hex unit</span>
<span class="sd">        :return: (list) of indices of empty neighbouring tiles</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">getNeighbours</span><span class="p">(</span><span class="n">hexField</span><span class="p">)</span>
        <span class="n">neighbours</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># 0. Remembering first mob from the queue position and filling it with zero, because in reachable neighbours</span>
        <span class="c1"># we want to include current position of the creature we move</span>
        <span class="n">mob</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">queue</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">mobx</span><span class="p">,</span> <span class="n">moby</span> <span class="o">=</span> <span class="n">mob</span><span class="o">.</span><span class="n">field</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">mobx</span><span class="p">,</span> <span class="n">moby</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># 1. Deleting not reachable neighbours</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">possibleMoves</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]:</span>
                <span class="k">del</span> <span class="n">neighbours</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="c1"># 2. Back to previous state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">mobx</span><span class="p">,</span> <span class="n">moby</span><span class="p">]</span> <span class="o">=</span> <span class="n">mob</span>

        <span class="k">return</span> <span class="n">neighbours</span>

    <span class="k">def</span> <span class="nf">__event_CreatureAtTheEndOfPossibleMoves</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">possibleMoves</span><span class="p">,</span> <span class="n">neighbour</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">mob</span><span class="p">:</span> <span class="n">CreatureBox</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if there is an enemy at the edge of possible moves. If so adds that tile to the possible moves</span>

<span class="sd">        :param possibleMoves: (np.array) 2D - non-zero elements are the tiles the unit can move on</span>
<span class="sd">        :param neighbour:   (tuple) checked tile at the edge of possible moves</span>
<span class="sd">        :param mob: (CreatureBox) currently moving unit</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">neighbour</span><span class="p">],</span> <span class="n">CreatureBox</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">neighbour</span><span class="p">]</span><span class="o">.</span><span class="n">ally</span> <span class="o">!=</span> <span class="n">mob</span><span class="o">.</span><span class="n">ally</span><span class="p">:</span>
                <span class="n">possibleMoves</span><span class="p">[</span><span class="n">neighbour</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">__deleteObstaclesFromPossibleMoves</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">possibleMoves</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets tiles containing obstacles to 0 in possible moves array</span>

<span class="sd">        :param possibleMoves: (np.array) 2D - non-zero elements are the tiles the unit can move on</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">15</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">11</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span> <span class="n">Obstacle</span><span class="p">):</span>
                    <span class="n">possibleMoves</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">__deleteAlliedCreaturesFromPossibleMoves</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">possibleMoves</span><span class="p">,</span> <span class="n">mob</span><span class="p">:</span> <span class="n">CreatureBox</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets tiles containing ally creatures to 0 in possible moves array</span>

<span class="sd">        :param possibleMoves: (np.array) 2D - non-zero elements are the tiles the unit can move on</span>
<span class="sd">        :param mob: (CreatureBox) - currently moving unit</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">15</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">11</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span> <span class="n">CreatureBox</span><span class="p">):</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span><span class="o">.</span><span class="n">ally</span> <span class="o">==</span> <span class="n">mob</span><span class="o">.</span><span class="n">ally</span> <span class="ow">and</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">!=</span> <span class="n">mob</span><span class="o">.</span><span class="n">field</span><span class="p">:</span>
                        <span class="n">possibleMoves</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">__addAllOpponentsToPossibleMoves</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">possibleMoves</span><span class="p">,</span> <span class="n">mob</span><span class="p">:</span> <span class="n">CreatureBox</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">         Sets tiles containing opponent tiles to 1</span>
<span class="sd">         Useful for evaluating possible moves of ranged unit</span>

<span class="sd">         :param possibleMoves: (np.array) 2D - non-zero elements are the tiles the unit can move on</span>
<span class="sd">         :param mob: (CreatureBox) - currently moving unit</span>
<span class="sd">         &quot;&quot;&quot;</span>
        <span class="n">neighbours</span> <span class="o">=</span> <span class="n">getNeighbours</span><span class="p">(</span><span class="n">mob</span><span class="o">.</span><span class="n">field</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
        <span class="n">neighbours</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">neighbours</span> <span class="k">if</span>
                      <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">CreatureBox</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">ally</span> <span class="o">!=</span> <span class="n">mob</span><span class="o">.</span><span class="n">ally</span><span class="p">)]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">neighbours</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">11</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">15</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span> <span class="n">CreatureBox</span><span class="p">):</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span><span class="o">.</span><span class="n">ally</span> <span class="o">!=</span> <span class="n">mob</span><span class="o">.</span><span class="n">ally</span><span class="p">:</span>
                            <span class="n">possibleMoves</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">__possibleMovesFlying</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mob</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Algorithm:</span>
<span class="sd">        0. Initialize possible moves table with zeros: np.zeros((15, 11))</span>
<span class="sd">        1. Start algorithm from field where creature we are moving is standing and add this field to &quot;to visit&quot; list</span>
<span class="sd">           This field is current node. Set value of this node as speed of the creature.</span>
<span class="sd">        2. Get neighbours of this field</span>

<span class="sd">        Do followings for each neighbour</span>
<span class="sd">        3. If current node has value greater than 1, so we have energy for continue moving, add neighbour</span>
<span class="sd">           to &quot;to visit&quot; list (it adding all the neighbours or no neighbour)</span>
<span class="sd">        4. If current node has value equal to 1 we need to check neighbours of this field one more time to check for</span>
<span class="sd">           creatures in neighbourhood of this field. This is necessary, because when we can reach neighbourhood of</span>
<span class="sd">           a creature, we can attack it too (so move should be possible). So check if this neighbour is a creature.</span>
<span class="sd">           If it is, set value of this neighbour to 1. (this triggers only when current node is equal to 1)</span>
<span class="sd">        5. If value of the node is not equal to 0 (value has not been set), set value of this node to currentNode value - 1</span>

<span class="sd">        6. Add currentNode to visited and delete it from &quot;to visit&quot; list</span>
<span class="sd">        7. Repeat algorithm to time when we do not have any node to visit (&quot;to visit&quot; list is empty)</span>

<span class="sd">        :return: (np.array) 2D - non-zero elements are the tiles the unit can move on</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Get first mob from queue</span>
        <span class="c1"># mob = self.queue.queue[-1]</span>
        <span class="n">speed</span> <span class="o">=</span> <span class="n">mob</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">speed</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">toVisit</span> <span class="o">=</span> <span class="p">[</span><span class="n">mob</span><span class="o">.</span><span class="n">field</span><span class="p">]</span>

        <span class="c1"># Initialization</span>
        <span class="n">possibleMoves</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">15</span><span class="p">,</span> <span class="mi">11</span><span class="p">))</span>
        <span class="n">possibleMoves</span><span class="p">[</span><span class="n">mob</span><span class="o">.</span><span class="n">field</span><span class="p">]</span> <span class="o">=</span> <span class="n">speed</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">toVisit</span><span class="p">):</span>
            <span class="c1"># Get neighbours of the current node</span>
            <span class="n">currentNode</span> <span class="o">=</span> <span class="n">toVisit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">neighbours</span> <span class="o">=</span> <span class="n">getNeighbours</span><span class="p">(</span><span class="n">currentNode</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">neighbour</span> <span class="ow">in</span> <span class="n">neighbours</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">neighbour</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                    <span class="c1"># Add next nodes to visit</span>
                    <span class="k">if</span> <span class="n">possibleMoves</span><span class="p">[</span><span class="n">currentNode</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">toVisit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neighbour</span><span class="p">)</span>

                    <span class="c1"># If this is the end check for creatures in neighbourhood</span>
                    <span class="k">elif</span> <span class="n">possibleMoves</span><span class="p">[</span><span class="n">currentNode</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">__event_CreatureAtTheEndOfPossibleMoves</span><span class="p">(</span><span class="n">possibleMoves</span><span class="p">,</span> <span class="n">neighbour</span><span class="p">,</span> <span class="n">mob</span><span class="p">)</span>

                    <span class="c1"># If value of the neighbour has not been set, set value to value of current node minus 1</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">possibleMoves</span><span class="p">[</span><span class="n">neighbour</span><span class="p">]:</span>
                        <span class="n">possibleMoves</span><span class="p">[</span><span class="n">neighbour</span><span class="p">]</span> <span class="o">=</span> <span class="n">possibleMoves</span><span class="p">[</span><span class="n">currentNode</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="c1"># Add current node to visited and delete it from &quot;to visit&quot; list</span>
            <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">currentNode</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">toVisit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">possibleMoves</span>

    <span class="k">def</span> <span class="nf">__possibleMovesFlying1Hex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mob</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluates possible moves of 1-hex flying unit</span>
<span class="sd">        sets all tiles as possible move except tiles containing allies and obstacles if unit&#39;s speed is</span>
<span class="sd">        greater or equal 18. Calls __possibleMovesFlying() otherwise</span>

<span class="sd">        :param mob: (CreatureBox) - currently moving unit</span>
<span class="sd">        :return: (np.array) 2D - non-zero elements are the tiles the unit can move on</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">mob</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">speed</span> <span class="o">&gt;=</span> <span class="mi">18</span><span class="p">:</span>
            <span class="n">possibleMoves</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">15</span><span class="p">,</span> <span class="mi">11</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">possibleMoves</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__possibleMovesFlying</span><span class="p">(</span><span class="n">mob</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__deleteAlliedCreaturesFromPossibleMoves</span><span class="p">(</span><span class="n">possibleMoves</span><span class="p">,</span> <span class="n">mob</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__deleteObstaclesFromPossibleMoves</span><span class="p">(</span><span class="n">possibleMoves</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mob</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">ammo</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">__addAllOpponentsToPossibleMoves</span><span class="p">(</span><span class="n">possibleMoves</span><span class="p">,</span> <span class="n">mob</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">possibleMoves</span>

    <span class="k">def</span> <span class="nf">__possibleMovesFlying2Hex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mob</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluates possible moves of 1-hex flying unit</span>
<span class="sd">        sets all tiles as possible move except tiles containing allies and obstacles if unit&#39;s speed is</span>
<span class="sd">        greater or equal 17. Calls __possibleMovesFlying() otherwise. Proceeds with some postprocessing afterwards.</span>

<span class="sd">        :param mob: (CreatureBox) - currently moving unit</span>
<span class="sd">        :return: (np.array) 2D - non-zero elements are the tiles the unit can move on</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># 1. Take possibleMoves for flying units and do some postprocessing</span>
        <span class="c1"># after defining possibleMoves we have to do some postprocessing to get realPossibleMoves true for 2hex units</span>
        <span class="c1"># possibleMoves here are only candidates for realPossibleMoves bc we need to have 2hex space for entering it</span>
        <span class="k">if</span> <span class="n">mob</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">speed</span> <span class="o">&gt;=</span> <span class="mi">17</span><span class="p">:</span>
            <span class="n">possibleMoves</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">15</span><span class="p">,</span> <span class="mi">11</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">possibleMoves</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__possibleMovesFlying</span><span class="p">(</span><span class="n">mob</span><span class="p">)</span>

        <span class="c1"># 2. Initializing some variables for code reduction</span>
        <span class="k">if</span> <span class="n">mob</span><span class="o">.</span><span class="n">ally</span><span class="p">:</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># if mob is ally we need to check left side firstly</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># for ally start of board is 0</span>
            <span class="n">end</span> <span class="o">=</span> <span class="mi">14</span>  <span class="c1"># and end of board is 14, this is needed for boundary cases execution</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">14</span>
            <span class="n">end</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># 3. Defining realPossibleMoves</span>
        <span class="n">realPossibleMoves</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">15</span><span class="p">,</span> <span class="mi">11</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">11</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">15</span><span class="p">):</span>
                <span class="c1"># Boundary case</span>
                <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">start</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">tail</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> \
                            <span class="ow">and</span> <span class="n">possibleMoves</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="ow">and</span> <span class="n">possibleMoves</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">tail</span><span class="p">,</span> <span class="n">y</span><span class="p">]:</span>
                        <span class="n">realPossibleMoves</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="c1"># Boundary case 2</span>
                <span class="k">elif</span> <span class="n">x</span> <span class="o">==</span> <span class="n">end</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="n">tail</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">tail</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">==</span> <span class="n">mob</span><span class="o">.</span><span class="n">field</span><span class="p">)</span> \
                            <span class="ow">and</span> <span class="n">possibleMoves</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="ow">and</span> <span class="n">possibleMoves</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="n">tail</span><span class="p">,</span> <span class="n">y</span><span class="p">]:</span>
                        <span class="n">realPossibleMoves</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="c1"># Firstly check default side for tail</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="n">tail</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">tail</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">==</span> <span class="n">mob</span><span class="o">.</span><span class="n">field</span><span class="p">)</span> \
                        <span class="ow">and</span> <span class="n">possibleMoves</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="ow">and</span> <span class="n">possibleMoves</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="n">tail</span><span class="p">,</span> <span class="n">y</span><span class="p">]:</span>
                    <span class="n">realPossibleMoves</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="c1"># Then check default the other side</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">tail</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> \
                        <span class="ow">and</span> <span class="n">possibleMoves</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="ow">and</span> <span class="n">possibleMoves</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">tail</span><span class="p">,</span> <span class="n">y</span><span class="p">]:</span>
                    <span class="n">realPossibleMoves</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># 4. Adding to realPossibleMoves current position of unit we move</span>
        <span class="n">realPossibleMoves</span><span class="p">[</span><span class="n">mob</span><span class="o">.</span><span class="n">field</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">realPossibleMoves</span><span class="p">[</span><span class="n">mob</span><span class="o">.</span><span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">tail</span><span class="p">,</span> <span class="n">mob</span><span class="o">.</span><span class="n">field</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># 5. Extending realPossibleMoves at the start side of the unit (if ally left, if not right)</span>
        <span class="k">if</span> <span class="n">mob</span><span class="o">.</span><span class="n">ally</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">11</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">13</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">realPossibleMoves</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">realPossibleMoves</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                            <span class="k">break</span>  <span class="c1"># go to the next row</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">11</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">realPossibleMoves</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">realPossibleMoves</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                            <span class="k">break</span>  <span class="c1"># go to the next row</span>

        <span class="c1"># 6. Appending creatures in range to realPossibleMoves</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">11</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">15</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span> <span class="n">CreatureBox</span><span class="p">):</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span><span class="o">.</span><span class="n">ally</span> <span class="o">!=</span> <span class="n">mob</span><span class="o">.</span><span class="n">ally</span><span class="p">:</span>
                        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__getEmptyNeighbours2Hex</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
                        <span class="k">for</span> <span class="n">neigh</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">neigh</span><span class="p">],</span> <span class="n">CreatureBox</span><span class="p">):</span>
                                <span class="k">continue</span>
                            <span class="k">if</span> <span class="n">realPossibleMoves</span><span class="p">[</span><span class="n">neigh</span><span class="p">]:</span>
                                <span class="n">realPossibleMoves</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">mob</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">ammo</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">__addAllOpponentsToPossibleMoves</span><span class="p">(</span><span class="n">possibleMoves</span><span class="p">,</span> <span class="n">mob</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">realPossibleMoves</span>

    <span class="k">def</span> <span class="nf">__possibleMovesLand1Hex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mob</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluates possible moves of non-flying 1-hex unit</span>

<span class="sd">        :param mob: (CreatureBox) - currently moving unit</span>
<span class="sd">        :return: (np.array) 2D - non-zero elements are the tiles the unit can move on</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">speed</span> <span class="o">=</span> <span class="n">mob</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">speed</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">toVisit</span> <span class="o">=</span> <span class="p">[</span><span class="n">mob</span><span class="o">.</span><span class="n">field</span><span class="p">]</span>

        <span class="c1"># Initialization</span>
        <span class="n">possibleMoves</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">15</span><span class="p">,</span> <span class="mi">11</span><span class="p">))</span>
        <span class="n">possibleMoves</span><span class="p">[</span><span class="n">mob</span><span class="o">.</span><span class="n">field</span><span class="p">]</span> <span class="o">=</span> <span class="n">speed</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">toVisit</span><span class="p">):</span>
            <span class="c1"># Get neighbours of the current node</span>
            <span class="n">currentNode</span> <span class="o">=</span> <span class="n">toVisit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">neighbours</span> <span class="o">=</span> <span class="n">getNeighbours</span><span class="p">(</span><span class="n">currentNode</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">neighbour</span> <span class="ow">in</span> <span class="n">neighbours</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">neighbour</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                    <span class="c1"># Add next nodes to visit</span>
                    <span class="k">if</span> <span class="n">possibleMoves</span><span class="p">[</span><span class="n">currentNode</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">neighbour</span><span class="p">],</span> <span class="n">Obstacle</span><span class="p">):</span> <span class="n">toVisit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neighbour</span><span class="p">)</span>

                    <span class="c1"># If this is the end check for creatures in neighbourhood</span>
                    <span class="k">elif</span> <span class="n">possibleMoves</span><span class="p">[</span><span class="n">currentNode</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">currentNode</span><span class="p">],</span> <span class="n">CreatureBox</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">__event_CreatureAtTheEndOfPossibleMoves</span><span class="p">(</span><span class="n">possibleMoves</span><span class="p">,</span> <span class="n">neighbour</span><span class="p">,</span> <span class="n">mob</span><span class="p">)</span>

                    <span class="c1"># If value of the neighbour has not been set, set value to value of current node minus 1</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">possibleMoves</span><span class="p">[</span><span class="n">neighbour</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">possibleMoves</span><span class="p">[</span><span class="n">currentNode</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">neighbour</span><span class="p">],</span> <span class="n">CreatureBox</span><span class="p">):</span>
                            <span class="n">possibleMoves</span><span class="p">[</span><span class="n">neighbour</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">neighbour</span><span class="p">],</span> <span class="n">Obstacle</span><span class="p">):</span>
                            <span class="n">possibleMoves</span><span class="p">[</span><span class="n">neighbour</span><span class="p">]</span> <span class="o">=</span> <span class="n">possibleMoves</span><span class="p">[</span><span class="n">currentNode</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="c1"># Add current node to visited and delete it from &quot;to visit&quot; list</span>
            <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">currentNode</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">toVisit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Deleting ally creatures from possible moves except creature we moves</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__deleteAlliedCreaturesFromPossibleMoves</span><span class="p">(</span><span class="n">possibleMoves</span><span class="p">,</span> <span class="n">mob</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">mob</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">ammo</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">__addAllOpponentsToPossibleMoves</span><span class="p">(</span><span class="n">possibleMoves</span><span class="p">,</span> <span class="n">mob</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">possibleMoves</span>

    <span class="k">def</span> <span class="nf">__possibleMovesLand2Hex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mob</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluates possible moves of non-flying 2-hex unit</span>

<span class="sd">        :param mob: (CreatureBox) - currently moving unit</span>
<span class="sd">        :return: (np.array) 2D - non-zero elements are the tiles the unit can move on</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">speed</span> <span class="o">=</span> <span class="n">mob</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">speed</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># 1. Initializing some variables for code reduction</span>
        <span class="k">if</span> <span class="n">mob</span><span class="o">.</span><span class="n">ally</span><span class="p">:</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># if mob is ally we need to check left side firstly</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># for ally start of board is 0</span>
            <span class="n">end</span> <span class="o">=</span> <span class="mi">14</span>  <span class="c1"># and end of board is 14, this is needed for boundary cases execution</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">14</span>
            <span class="n">end</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># 2. Creating new thicker state (making obstacles and creatures one hex thicker)</span>
        <span class="n">hex2State</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">15</span><span class="p">,</span> <span class="mi">11</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">11</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">tail</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span> <span class="n">Obstacle</span><span class="p">):</span>
                    <span class="n">hex2State</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">hex2State</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">tail</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span> <span class="n">CreatureBox</span><span class="p">):</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span><span class="o">.</span><span class="n">field</span> <span class="o">!=</span> <span class="n">mob</span><span class="o">.</span><span class="n">field</span><span class="p">:</span>
                        <span class="n">hex2State</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
                        <span class="n">hex2State</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">tail</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>

                <span class="k">elif</span> <span class="n">x</span> <span class="o">==</span> <span class="n">start</span><span class="p">:</span>
                    <span class="n">hex2State</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># 3. Candidates for possible moves initialization</span>
        <span class="n">possibleMoves</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">15</span><span class="p">,</span> <span class="mi">11</span><span class="p">))</span>
        <span class="n">possibleMoves</span><span class="p">[</span><span class="n">mob</span><span class="o">.</span><span class="n">field</span><span class="p">]</span> <span class="o">=</span> <span class="n">speed</span>
        <span class="n">possibleMoves</span><span class="p">[</span><span class="n">mob</span><span class="o">.</span><span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">tail</span><span class="p">,</span> <span class="n">mob</span><span class="o">.</span><span class="n">field</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">speed</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="c1"># 4. Classic 1hex possibleMoves algorithm but with two initial hexes in toVisit list</span>
        <span class="n">toVisit</span> <span class="o">=</span> <span class="p">[</span><span class="n">mob</span><span class="o">.</span><span class="n">field</span><span class="p">,</span> <span class="p">(</span><span class="n">mob</span><span class="o">.</span><span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">tail</span><span class="p">,</span> <span class="n">mob</span><span class="o">.</span><span class="n">field</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">toVisit</span><span class="p">):</span>
            <span class="c1"># Get neighbours of the current node</span>
            <span class="n">currentNode</span> <span class="o">=</span> <span class="n">toVisit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">neighbours</span> <span class="o">=</span> <span class="n">getNeighbours</span><span class="p">(</span><span class="n">currentNode</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">neighbour</span> <span class="ow">in</span> <span class="n">neighbours</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">neighbour</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                    <span class="c1"># Add next nodes to visit</span>
                    <span class="k">if</span> <span class="n">possibleMoves</span><span class="p">[</span><span class="n">currentNode</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">hex2State</span><span class="p">[</span><span class="n">neighbour</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="n">toVisit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neighbour</span><span class="p">)</span>

                    <span class="c1"># If this is the end check for creatures in neighbourhood</span>
                    <span class="k">elif</span> <span class="n">possibleMoves</span><span class="p">[</span><span class="n">currentNode</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">hex2State</span><span class="p">[</span><span class="n">currentNode</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">__event_CreatureAtTheEndOfPossibleMoves</span><span class="p">(</span><span class="n">possibleMoves</span><span class="p">,</span> <span class="n">neighbour</span><span class="p">,</span> <span class="n">mob</span><span class="p">)</span>

                    <span class="c1"># If value of the neighbour has not been set, set value to value of current node minus 1</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">possibleMoves</span><span class="p">[</span><span class="n">neighbour</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">possibleMoves</span><span class="p">[</span><span class="n">currentNode</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">hex2State</span><span class="p">[</span><span class="n">neighbour</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                            <span class="n">possibleMoves</span><span class="p">[</span><span class="n">neighbour</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

                        <span class="k">elif</span> <span class="ow">not</span> <span class="n">hex2State</span><span class="p">[</span><span class="n">neighbour</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">possibleMoves</span><span class="p">[</span><span class="n">neighbour</span><span class="p">]</span> <span class="o">=</span> <span class="n">possibleMoves</span><span class="p">[</span><span class="n">currentNode</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="c1"># Add current node to visited and delete it from &quot;to visit&quot; list</span>
            <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">currentNode</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">toVisit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># 5. Defining realPossibleMoves</span>
        <span class="n">realPossibleMoves</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">15</span><span class="p">,</span> <span class="mi">11</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">11</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">15</span><span class="p">):</span>
                <span class="c1"># Boundary case</span>
                <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">start</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">tail</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> \
                            <span class="ow">and</span> <span class="n">possibleMoves</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="ow">and</span> <span class="n">possibleMoves</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">tail</span><span class="p">,</span> <span class="n">y</span><span class="p">]:</span>
                        <span class="n">realPossibleMoves</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="c1"># Boundary case 2</span>
                <span class="k">elif</span> <span class="n">x</span> <span class="o">==</span> <span class="n">end</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="n">tail</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">tail</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">==</span> <span class="n">mob</span><span class="o">.</span><span class="n">field</span><span class="p">)</span> \
                            <span class="ow">and</span> <span class="n">possibleMoves</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="ow">and</span> <span class="n">possibleMoves</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="n">tail</span><span class="p">,</span> <span class="n">y</span><span class="p">]:</span>
                        <span class="n">realPossibleMoves</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="c1"># Firstly check default side for tail</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="n">tail</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">tail</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">==</span> <span class="n">mob</span><span class="o">.</span><span class="n">field</span><span class="p">)</span> \
                        <span class="ow">and</span> <span class="n">possibleMoves</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]:</span>  <span class="c1"># and possibleMoves[x - tail, y]:</span>
                    <span class="n">realPossibleMoves</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="c1"># Then check default the other side</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">tail</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> \
                        <span class="ow">and</span> <span class="n">possibleMoves</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="ow">and</span> <span class="n">possibleMoves</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">tail</span><span class="p">,</span> <span class="n">y</span><span class="p">]:</span>
                    <span class="n">realPossibleMoves</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># 6. Adding to realPossibleMoves current position of unit we move</span>
        <span class="n">realPossibleMoves</span><span class="p">[</span><span class="n">mob</span><span class="o">.</span><span class="n">field</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">realPossibleMoves</span><span class="p">[</span><span class="n">mob</span><span class="o">.</span><span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">tail</span><span class="p">,</span> <span class="n">mob</span><span class="o">.</span><span class="n">field</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># 7. Extending realPossibleMoves at the start side of the unit (if ally left, if not right)</span>
        <span class="k">if</span> <span class="n">mob</span><span class="o">.</span><span class="n">ally</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">11</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">13</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">realPossibleMoves</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">realPossibleMoves</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">11</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">realPossibleMoves</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">realPossibleMoves</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># 8. Appending creatures in range to realPossibleMoves</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">11</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">15</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span> <span class="n">CreatureBox</span><span class="p">):</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span><span class="o">.</span><span class="n">ally</span> <span class="o">!=</span> <span class="n">mob</span><span class="o">.</span><span class="n">ally</span><span class="p">:</span>
                        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__getEmptyNeighbours2Hex</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
                        <span class="k">for</span> <span class="n">neigh</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">neigh</span><span class="p">],</span> <span class="n">CreatureBox</span><span class="p">):</span>
                                <span class="k">continue</span>
                            <span class="k">if</span> <span class="n">realPossibleMoves</span><span class="p">[</span><span class="n">neigh</span><span class="p">]:</span>
                                <span class="n">realPossibleMoves</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">mob</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">ammo</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">__addAllOpponentsToPossibleMoves</span><span class="p">(</span><span class="n">possibleMoves</span><span class="p">,</span> <span class="n">mob</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">realPossibleMoves</span>

<div class="viewcode-block" id="Environment.filter_possible_moves"><a class="viewcode-back" href="../../battleAI.html#battleAI.reinforcmentLearningTest.Environment.filter_possible_moves">[docs]</a>    <span class="k">def</span> <span class="nf">filter_possible_moves</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mob</span><span class="p">:</span> <span class="n">CreatureBox</span><span class="p">,</span> <span class="n">possibleMoves</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Makes additional limitations to possibleMoves based on our strategy :param mob: (CreatureBox) - currently</span>
<span class="sd">        moving</span>

<span class="sd">        :param possibleMoves: (np.array) 2D - non-zero elements are the tiles the unit can move on</span>
<span class="sd">        :return: (np.array) 2D - non-zero elements are the tiles the unit can move on, (np.array) 2D - non-zero elements</span>
<span class="sd">         are the tiles the unit can move on limited to only those we allow it to move on</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># make range unit able to only shoot if not blocked</span>
        <span class="n">alternatePossibleMoves</span> <span class="o">=</span> <span class="n">possibleMoves</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">notMaskedPossibleMoves</span> <span class="o">=</span> <span class="n">possibleMoves</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">training</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">training</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">mob</span><span class="o">.</span><span class="n">ally</span><span class="p">):</span>
            <span class="n">notBlocked</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">mob</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">ammo</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">15</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">11</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">possibleMoves</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span> <span class="n">CreatureBox</span><span class="p">)</span> <span class="ow">and</span> \
                                <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span><span class="o">.</span><span class="n">ally</span> <span class="o">!=</span> <span class="n">mob</span><span class="o">.</span><span class="n">ally</span><span class="p">:</span>
                            <span class="n">alternatePossibleMoves</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                            <span class="n">notBlocked</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">alternatePossibleMoves</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">notBlocked</span><span class="p">:</span>
                <span class="n">possibleMoves</span> <span class="o">=</span> <span class="n">alternatePossibleMoves</span>
            <span class="c1"># make melee unit able to only attack if it can</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">15</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">11</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">possibleMoves</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span> <span class="n">CreatureBox</span><span class="p">)</span> <span class="ow">and</span> \
                                <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span><span class="o">.</span><span class="n">ally</span> <span class="o">!=</span> <span class="n">mob</span><span class="o">.</span><span class="n">ally</span><span class="p">:</span>
                            <span class="c1"># check if there is an empty hex to attack enemy from</span>
                            <span class="k">if</span> <span class="n">mob</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                                <span class="n">neighbours</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__getEmptyNeighbours</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">neighbours</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__getEmptyNeighbours2Hex</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>

                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">neighbours</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="n">alternatePossibleMoves</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                                <span class="n">notBlocked</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">alternatePossibleMoves</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">alternatePossibleMoves</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">notBlocked</span><span class="p">:</span>
                <span class="n">possibleMoves</span> <span class="o">=</span> <span class="n">alternatePossibleMoves</span>

        <span class="k">return</span> <span class="n">notMaskedPossibleMoves</span><span class="p">,</span> <span class="n">possibleMoves</span></div>

<div class="viewcode-block" id="Environment.choosePossibleMoves"><a class="viewcode-back" href="../../battleAI.html#battleAI.reinforcmentLearningTest.Environment.choosePossibleMoves">[docs]</a>    <span class="k">def</span> <span class="nf">choosePossibleMoves</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mob</span><span class="p">:</span> <span class="n">CreatureBox</span><span class="p">,</span> <span class="n">update</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Main function to execute appropriate possible moves evaluation</span>

<span class="sd">        :param mob: (CreatureBox) - currently moving unit</span>
<span class="sd">        :return: (np.array) 2D - non-zero elements are the tiles the unit can move on,</span>
<span class="sd">            (np.array) 2D - non-zero elements are the tiles the unit can move on limited to only those we allow it to move on</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">mob</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;Catapult&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">possibleMoves</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">15</span><span class="p">,</span> <span class="mi">11</span><span class="p">))</span>
            <span class="n">destructible</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">coordinate</span> <span class="k">for</span> <span class="n">coordinate</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">destructible_walls</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">destructible_walls</span><span class="p">[</span><span class="n">coordinate</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">possibleMoves</span><span class="p">[</span><span class="n">destructible</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">destructible</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">possibleMoves</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">possibleMoves</span>

        <span class="k">if</span> <span class="n">mob</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;FirstAid&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">possibleMoves</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">15</span><span class="p">,</span> <span class="mi">11</span><span class="p">))</span>
            <span class="n">ally_fields</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">unit</span><span class="o">.</span><span class="n">field</span> <span class="k">for</span> <span class="n">unit</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">queue</span> <span class="k">if</span> <span class="n">unit</span><span class="o">.</span><span class="n">ally</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">possibleMoves</span><span class="p">[</span><span class="n">ally_fields</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">ally_fields</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">possibleMoves</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">possibleMoves</span>

        <span class="k">if</span> <span class="n">mob</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">mob</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">fly</span><span class="p">:</span>
                <span class="n">possibleMoves</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__possibleMovesFlying2Hex</span><span class="p">(</span><span class="n">mob</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">possibleMoves</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__possibleMovesLand2Hex</span><span class="p">(</span><span class="n">mob</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">mob</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">fly</span><span class="p">:</span>
                <span class="n">possibleMoves</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__possibleMovesFlying1Hex</span><span class="p">(</span><span class="n">mob</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">possibleMoves</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__possibleMovesLand1Hex</span><span class="p">(</span><span class="n">mob</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">update</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">possibleMoves</span> <span class="o">=</span> <span class="n">possibleMoves</span>

        <span class="n">notMaskedPossibleMoves</span><span class="p">,</span> <span class="n">possibleMoves</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_possible_moves</span><span class="p">(</span><span class="n">mob</span><span class="p">,</span> <span class="n">possibleMoves</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">notMaskedPossibleMoves</span><span class="p">,</span> <span class="n">possibleMoves</span></div>

<div class="viewcode-block" id="Environment.moveCreature"><a class="viewcode-back" href="../../battleAI.html#battleAI.reinforcmentLearningTest.Environment.moveCreature">[docs]</a>    <span class="k">def</span> <span class="nf">moveCreature</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hexField</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">update_possible_moves</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulates the move of a unit. Executes proper action depending on chosen tile</span>

<span class="sd">        :param hexField: (tuple) - indices of chosen tile to move on</span>
<span class="sd">        :return: (tuple) - indices of chosen tile to move on,</span>
<span class="sd">            (str) - side of the attack target we attack it from</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">illegalMove</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Set illegal move to false by default</span>
        <span class="n">mob</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">queue</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># Take first creature from queue</span>
        <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="n">mob</span><span class="o">.</span><span class="n">field</span>  <span class="c1"># Move from (x1, y1) to (x2, y2)</span>
        <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">hexField</span>

        <span class="k">if</span> <span class="n">mob</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;Catapult&quot;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">training</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">move</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">hexField</span><span class="p">,</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">mob</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;FirstAid&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">move</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">hexField</span><span class="p">,</span> <span class="kc">None</span>

        <span class="c1"># Choose right move type depending on the creature type:</span>
        <span class="k">if</span> <span class="n">update_possible_moves</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">possibleMoves</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">choosePossibleMoves</span><span class="p">(</span><span class="n">mob</span><span class="p">)</span>

        <span class="c1"># Move only if possibleMove array (15x11) returns that targetField is possible to move on</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">possibleMoves</span><span class="p">[</span><span class="n">x2</span><span class="p">][</span><span class="n">y2</span><span class="p">]</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x2</span><span class="p">][</span><span class="n">y2</span><span class="p">],</span> <span class="n">Obstacle</span><span class="p">):</span>
            <span class="c1"># If targetField is creature, we are testing ally</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x2</span><span class="p">][</span><span class="n">y2</span><span class="p">],</span> <span class="n">CreatureBox</span><span class="p">):</span>
                <span class="c1"># If targetField is enemy creature we need to decide from which side we want to attack</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x1</span><span class="p">][</span><span class="n">y1</span><span class="p">]</span><span class="o">.</span><span class="n">ally</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x2</span><span class="p">][</span><span class="n">y2</span><span class="p">]</span><span class="o">.</span><span class="n">ally</span><span class="p">:</span>
                    <span class="n">mob</span><span class="o">.</span><span class="n">waited</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">neighbours</span> <span class="o">=</span> <span class="n">getNeighbours</span><span class="p">((</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">))</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
                    <span class="n">neighbours</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">neighbours</span> <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">CreatureBox</span><span class="p">)</span> <span class="ow">and</span>
                                                            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">ally</span> <span class="o">!=</span> <span class="n">mob</span><span class="o">.</span><span class="n">ally</span><span class="p">)]</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x1</span><span class="p">][</span><span class="n">y1</span><span class="p">]</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">ammo</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">neighbours</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">move</span><span class="p">()</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">__rangeAttack</span><span class="p">((</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">))</span>
                        <span class="k">return</span> <span class="n">hexField</span><span class="p">,</span> <span class="kc">None</span>

                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">mob</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">attackSide</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__movingAndAttacking</span><span class="p">((</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">),</span> <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">))</span>
                            <span class="k">return</span> <span class="n">hexField</span><span class="p">,</span> <span class="n">attackSide</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">attackSide</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__movingAndAttacking2Hex</span><span class="p">((</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">),</span> <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">))</span>
                            <span class="k">return</span> <span class="n">hexField</span><span class="p">,</span> <span class="n">attackSide</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">move</span><span class="p">()</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Defend&quot;</span><span class="p">)</span>  <span class="c1"># Wait</span>
                    <span class="k">return</span> <span class="n">hexField</span><span class="p">,</span> <span class="kc">None</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">mob</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__moving</span><span class="p">((</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">),</span> <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">))</span>
                    <span class="k">return</span> <span class="n">hexField</span><span class="p">,</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__moving2Hex</span><span class="p">((</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">),</span> <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">))</span>
                    <span class="k">return</span> <span class="n">hexField</span><span class="p">,</span> <span class="kc">None</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># print(&quot;I cant move on this hex&quot;)  # Cant move</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">illegalMove</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Environment.prepareInputForNN"><a class="viewcode-back" href="../../battleAI.html#battleAI.reinforcmentLearningTest.Environment.prepareInputForNN">[docs]</a>    <span class="k">def</span> <span class="nf">prepareInputForNN</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">currUnit</span><span class="p">,</span> <span class="n">update_possible_moves</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Input for neural network preparation</span>
<span class="sd">        Form (x, y, z)</span>
<span class="sd">        x, y: coordinates of the hex</span>
<span class="sd">        z: features of the hex (current hero/hero/obstacle/empty hex, num of creatures at the hex,</span>
<span class="sd">        attack, hp, speed, ammo)</span>
<span class="sd">        stats are negative for hostile creatures</span>
<span class="sd">        stats are zero for empty hex</span>

<span class="sd">        :return: (np.array) 3D - input for neural network</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">currPos</span> <span class="o">=</span> <span class="n">currUnit</span><span class="o">.</span><span class="n">field</span>
        <span class="n">inputNN</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">15</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">7</span><span class="p">))</span>
        <span class="c1"># [    0#        1#       2#      3#      4#        5#, 6 ]</span>
        <span class="c1"># [ai_value, possible, ally, enemy, empty, , current]</span>
        <span class="k">if</span> <span class="n">update_possible_moves</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">possible_moves</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">choosePossibleMoves</span><span class="p">(</span><span class="n">currUnit</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">possible_moves</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">possibleMoves</span>

        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>

                <span class="n">inputNN</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">inputNN</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">],</span> <span class="n">Obstacle</span><span class="p">):</span>
                    <span class="n">inputNN</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">][</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">],</span> <span class="n">CreatureBox</span><span class="p">):</span>
                    <span class="n">inputNN</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">value</span><span class="o">/</span><span class="mi">78845</span>
                    <span class="n">inputNN</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span><span class="o">.</span><span class="n">ally</span> <span class="k">else</span> <span class="mi">0</span>
                    <span class="n">inputNN</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span><span class="o">.</span><span class="n">ally</span> <span class="k">else</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="n">possible_moves</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">inputNN</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">inputNN</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="n">currPos</span> <span class="o">==</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
                    <span class="n">inputNN</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">][</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">inputNN</span></div>

<div class="viewcode-block" id="Environment.startTurn"><a class="viewcode-back" href="../../battleAI.html#battleAI.reinforcmentLearningTest.Environment.startTurn">[docs]</a>    <span class="k">def</span> <span class="nf">startTurn</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes unit from a queue and updates possibleMoves in environment according to it</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mob</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">queue</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">possibleMoves</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">choosePossibleMoves</span><span class="p">(</span><span class="n">mob</span><span class="p">)</span></div>

<div class="viewcode-block" id="Environment.printEnvironment"><a class="viewcode-back" href="../../battleAI.html#battleAI.reinforcmentLearningTest.Environment.printEnvironment">[docs]</a>    <span class="k">def</span> <span class="nf">printEnvironment</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prints our environment state in console</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">training</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">startTurn</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">11</span><span class="p">):</span>
            <span class="n">txt</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">15</span><span class="p">):</span>

                <span class="c1"># Drawing creatures</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">],</span> <span class="n">CreatureBox</span><span class="p">):</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span><span class="o">.</span><span class="n">ally</span><span class="p">:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">possibleMoves</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]:</span>
                            <span class="n">txt</span> <span class="o">+=</span> <span class="n">Colors</span><span class="o">.</span><span class="n">OKCYAN</span> <span class="o">+</span> <span class="s2">&quot;X &quot;</span> <span class="o">+</span> <span class="n">Colors</span><span class="o">.</span><span class="n">ENDC</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">txt</span> <span class="o">+=</span> <span class="n">Colors</span><span class="o">.</span><span class="n">OKBLUE</span> <span class="o">+</span> <span class="s2">&quot;X &quot;</span> <span class="o">+</span> <span class="n">Colors</span><span class="o">.</span><span class="n">ENDC</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">possibleMoves</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]:</span>
                            <span class="n">txt</span> <span class="o">+=</span> <span class="n">Colors</span><span class="o">.</span><span class="n">WARNING</span> <span class="o">+</span> <span class="s2">&quot;X &quot;</span> <span class="o">+</span> <span class="n">Colors</span><span class="o">.</span><span class="n">ENDC</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">txt</span> <span class="o">+=</span> <span class="n">Colors</span><span class="o">.</span><span class="n">FAIL</span> <span class="o">+</span> <span class="s2">&quot;X &quot;</span> <span class="o">+</span> <span class="n">Colors</span><span class="o">.</span><span class="n">ENDC</span>

                <span class="c1"># Drawing obstacles</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">],</span> <span class="n">Obstacle</span><span class="p">):</span>
                    <span class="n">txt</span> <span class="o">+=</span> <span class="n">Colors</span><span class="o">.</span><span class="n">BOLD</span> <span class="o">+</span> <span class="s2">&quot;X &quot;</span> <span class="o">+</span> <span class="n">Colors</span><span class="o">.</span><span class="n">ENDC</span>

                <span class="k">else</span><span class="p">:</span>  <span class="c1"># Drawing empty hexes</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">possibleMoves</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]:</span>
                        <span class="n">txt</span> <span class="o">+=</span> <span class="n">Colors</span><span class="o">.</span><span class="n">OKGREEN</span> <span class="o">+</span> <span class="nb">chr</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="n">Colors</span><span class="o">.</span><span class="n">ENDC</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">txt</span> <span class="o">+=</span> <span class="nb">chr</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span>

            <span class="k">if</span> <span class="n">even</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="n">txt</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-----------------------------&quot;</span><span class="p">)</span></div></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Fryderyk Róg, Kacper Plesiak, Michał Gruba, Tymoteusz Skrzyński, Mateusz Comblik, Bartosz Szczepanek, Alan Konopko, Mateusz Mikszewicz, Daniel Bil, Piotr Łyczko.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>